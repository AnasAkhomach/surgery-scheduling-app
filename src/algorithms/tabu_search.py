from datetime import datetime, timedelta
import random

class SurgeryScheduleTabuSearch:

    def __init__(self, start_hour, end_hour, operational_hours, initial_schedule, max_iterations, tabu_list_size, tabu_tenure):
        self.current_schedule = initial_schedule
        self.best_schedule = initial_schedule
        self.max_iterations = max_iterations
        self.tabu_list = []
        self.tabu_list_size = tabu_list_size
        self.tabu_tenure = tabu_tenure
        self.surgeon_schedules = surgeon_schedules
        self.start_hour = start_hour
        self.end_hour = end_hour
        self.operational_hours = operational_hours
        self.best_score = float('inf')
  

    def run(self):
        """
        Run the Tabu Search algorithm to find the optimized surgery schedule.
        """
        iteration = 0
        while iteration < self.max_iterations:
            neighbors = self.generate_neighbors(self.current_schedule)
            best_neighbor = None
            best_score = float('-inf')

            for neighbor in neighbors:
                move = self.identify_move(self.current_schedule, neighbor)
                if not self.is_tabu(move) or self.aspiration_criteria_met(neighbor):
                    score = self.evaluate_schedule(neighbor)
                    if score > best_score:
                        best_neighbor = neighbor
                        best_score = score

            if best_neighbor:
                self.update_tabu_list(move)
                self.current_schedule = best_neighbor
                if best_score > self.evaluate_schedule(self.best_schedule):
                    self.best_schedule = best_neighbor

            iteration += 1

        return self.best_schedule

    def generate_neighbors(self, schedule):

        """
        Generate a set of neighboring schedules by altering the given schedule.

        Neighbors are generated by:
        - Swapping two surgeries in the schedule.
        - Shifting surgery times.
        - Changing operating rooms.

        Args:
        schedule (list): The current schedule, represented as a list of surgeries.

        Returns:
        list: A list of neighboring schedules.
        """
        neighbors = []
        num_surgeries = len(schedule)
        num_rooms = max(s['room'] for s in schedule)  # Assuming room numbers start from 1

        # Swapping surgeries
        for i in range(num_surgeries):
            for j in range(i + 1, num_surgeries):
                neighbor = schedule.copy()
                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
                if self.is_valid_schedule(neighbor):
                    neighbors.append(neighbor)

        # Shifting surgery times
        for i in range(num_surgeries):
            neighbor = schedule.copy()
            shifted_time = self.shift_time(neighbor[i]['time'], random.choice([-1, 1]))
            if shifted_time:
                neighbor[i]['time'] = shifted_time
                if self.is_valid_schedule(neighbor):
                    neighbors.append(neighbor)

        # Changing operating rooms
        for i in range(num_surgeries):
            neighbor = schedule.copy()
            new_room = random.randint(1, num_rooms)
            neighbor[i]['room'] = new_room
            if self.is_valid_schedule(neighbor):
                neighbors.append(neighbor)

        return neighbors
# Hlpers for genrate_neighbors

    def is_valid_schedule(self, schedule):
        """
        Validate a given schedule by checking various constraints.

        Args:
        schedule (list): The schedule to validate, represented as a list of surgeries.

        Returns:
        bool: True if the schedule is valid, False otherwise.
        """
        if not self.check_surgeon_availability(schedule):
            return False

        if not self.check_room_availability(schedule):
            return False

        if not self.check_patient_safety_constraints(schedule):
            return False

        return True

## Helper functions for isValid
    def check_surgeon_availability(self, schedule):
        """
        Check if surgeons are available for their assigned surgeries.

        Args:
        schedule (list): The schedule to check.

        Returns:
        bool: True if all surgeons are available, False otherwise.
        """
        # Implement logic based on surgeons' schedules
        # Example: Check if surgeon is available at the time of surgery
        for surgery in schedule:
            surgeon_id = surgery['surgeon']
            time = surgery['time']
            if not self.is_surgeon_available(surgeon_id, time):
                return False
        return True

    def check_room_availability(self, schedule):
        """
        Check if operating rooms are available and not double-booked.

        Args:
        schedule (list): The schedule to check.

        Returns:
        bool: True if all rooms are available, False otherwise.
        """
        # Implement logic based on operating room schedules
        # Example: Check for overlapping surgery times in the same room
        room_schedules = {}  # Dict to track usage of rooms
        for surgery in schedule:
            room = surgery['room']
            time = surgery['time']
            if room in room_schedules and self.is_overlapping(time, room_schedules[room]):
                return False
            room_schedules[room] = time
        return True

    def check_patient_safety_constraints(self, schedule):
        """
        Ensure the schedule adheres to patient safety constraints.
        This includes checking for sufficient time between surgeries for the same patient.

        Args:
        schedule (list): The schedule to check, represented as a list of surgeries.

        Returns:
        bool: True if all safety constraints are met, False otherwise.
        """
        patient_surgery_times = {}  # Dictionary to track the last surgery time for each patient

        for surgery in schedule:
            patient_id = surgery['patient_id']
            surgery_time = self.convert_to_datetime(surgery['time'])
            surgery_duration = surgery['duration']

            if patient_id in patient_surgery_times:
                last_surgery_end_time = patient_surgery_times[patient_id]
                if not self.is_sufficient_recovery_time(last_surgery_end_time, surgery_time):
                    return False

            patient_surgery_times[patient_id] = surgery_time + timedelta(hours=surgery_duration)

        return True

## Helpers For check_patient_safety_constraints
    def is_sufficient_recovery_time(self, last_surgery_end_time, next_surgery_time):
        """
        Check if there is sufficient recovery time between surgeries for the same patient.

        Args:
        last_surgery_end_time (datetime): The end time of the last surgery.
        next_surgery_time (datetime): The start time of the next surgery.

        Returns:
        bool: True if there is sufficient recovery time, False otherwise.
        """
        minimum_recovery_time = timedelta(hours=6)  # Example: 6 hours minimum
        return (next_surgery_time - last_surgery_end_time) >= minimum_recovery_time
 
    def convert_to_datetime(self, time_str):
        """
        Convert a time string in 'HH:MM' format to a datetime object.

        Args:
        time_str (str): The time in 'HH:MM' format.

        Returns:
        datetime.datetime: The corresponding datetime object.
        """
        return datetime.strptime(time_str, '%H:%M')
## End Helpers For check_patient_safety_constraints

    def is_surgeon_available(self, surgeon_id, surgery_time):
        """
        Check if a surgeon is available at a given time for surgery.

        Args:
        surgeon_id (int): The ID of the surgeon.
        surgery_time (str): The time of the surgery in 'YYYY-MM-DD HH:MM' format.

        Returns:
        bool: True if the surgeon is available, False otherwise.
        """
        # Convert surgery_time string to a datetime object
        surgery_datetime = datetime.strptime(surgery_time, '%Y-%m-%d %H:%M')

        # Check the surgeon's availability
        if surgeon_id in self.surgeon_schedules:
            availability_periods = self.surgeon_schedules[surgeon_id]
            for period in availability_periods:
                if self.is_time_within_period(surgery_datetime, period):
                    return True

        return False

    def is_overlapping(self, time1, time2):
        """
        Check if two time periods overlap.

        Each time period is represented by a tuple (start_time, end_time), where
        start_time and end_time are strings in the 'YYYY-MM-DD HH:MM' format.

        Args:
        time1 (tuple): The first time period (start_time, end_time).
        time2 (tuple): The second time period (start_time, end_time).

        Returns:
        bool: True if the time periods overlap, False otherwise.
        """
        start1, end1 = map(self.convert_to_datetime, time1)
        start2, end2 = map(self.convert_to_datetime, time2)

        # Check for overlap
        return max(start1, start2) < min(end1, end2)
## End Helpers for isValid

    def shift_time(self, time_str, shift_hours):
        """
        Shift a surgery time by a specified number of hours.

        Args:
        time_str (str): The current time of the surgery in 'HH:MM' format.
        shift_hours (int): Number of hours to shift the surgery time.

        Returns:
        str or None: The new time in 'HH:MM' format, or None if the shift results in invalid time.
        """
        surgery_time = self.convert_to_datetime(time_str)
        shifted_time = surgery_time + timedelta(hours=shift_hours)
        if self.is_within_operational_hours(shifted_time):
            return shifted_time.strftime('%H:%M')
        return None
## Helpers For shift_time
    def is_within_operational_hours(self, time_obj):
        """
        Check if a given time is within the hospital's operational hours.

        Args:
        time_obj (datetime.datetime): The time to check.

        Returns:
        bool: True if the time is within operational hours, False otherwise.
        """
        # Example: Operational hours are from 08:00 to 18:00
        start_operational_hour = datetime.combine(time_obj.date(), datetime.min.time()) + timedelta(hours=8)
        end_operational_hour = datetime.combine(time_obj.date(), datetime.min.time()) + timedelta(hours=18)
        return start_operational_hour <= time_obj <= end_operational_hour
## End of Helpers For shift_time

    def is_within_operational_hours(self, time_obj):
        """
        Check if a given datetime object falls within operational hours.

        Args:
        time_obj (datetime.datetime): The time to check.

        Returns:
        bool: True if the time is within operational hours, False otherwise.
        """
        # Assuming operational hours are from 08:00 to 18:00
        start_operational_hour = self.convert_to_datetime('08:00')
        end_operational_hour = self.convert_to_datetime('18:00')
        return start_operational_hour <= time_obj <= end_operational_hour
    def convert_to_datetime(self, time_str, format_str='%Y-%m-%d %H:%M'):
        """
        Convert a string representing date and time to a datetime object.

        Args:
        time_str (str): The date and time string to be converted.
        format_str (str): The format string to interpret the time_str. 
                          Default is '%Y-%m-%d %H:%M' (e.g., '2023-07-01 09:00').

        Returns:
        datetime.datetime: The corresponding datetime object.
        """
        try:
            return datetime.strptime(time_str, format_str)
        except ValueError as e:
            print(f"Error converting time: {e}")
            return None

    def evaluate_schedule(self, schedule):
        """
        Evaluate the quality of a given schedule based on various criteria.

        Args:
        schedule (list): The schedule to evaluate, represented as a list of surgeries.

        Returns:
        float: The overall score of the schedule.
        """
        resource_utilization_score = self.calculate_resource_utilization_score(schedule)
        surgeon_workload_balance_score = self.calculate_surgeon_workload_balance_score(schedule)
        patient_wait_time_score = self.calculate_patient_wait_time_score(schedule)

        # Combine these scores into a final score
        final_score = (resource_utilization_score + surgeon_workload_balance_score + patient_wait_time_score) / 3
        return final_score
# Hlepers For evaluate_schedule
    def calculate_resource_utilization_score(self, schedule):
        """
        Calculate the resource utilization score based on how effectively the operating rooms are used.

        Args:
        schedule (list): The schedule to evaluate, represented as a list of surgeries.
                         Each surgery is assumed to have 'start_time', 'end_time', and 'room' attributes.

        Returns:
        float: The resource utilization score.
        """
        total_operating_time, used_operating_time = 0, 0

        for day, hours in self.operational_hours.items():
            total_operating_time += self.get_daily_operating_hours(hours)

        for surgery in schedule:
            surgery_duration = self.calculate_surgery_duration(surgery['start_time'], surgery['end_time'])
            used_operating_time += surgery_duration

        # Avoid division by zero
        if total_operating_time == 0:
            return 0

        return (used_operating_time / total_operating_time) * 100

    def calculate_surgery_duration(self, start, end):
        """
        Calculate the duration of a surgery.

        Args:
        start (str): Start time of the surgery.
        end (str): End time of the surgery.

        Returns:
        float: Duration of the surgery in hours.
        """
        start_time = self.convert_to_datetime(start)
        end_time = self.convert_to_datetime(end)
        return (end_time - start_time).total_seconds() / 3600  # Convert to hours
# End of Helpers evaluate_schedule

    def is_tabu(self, move):
        """
        Check if a move is in the Tabu list.

        Args:
        move (tuple): The move to check. A move can be represented by any data structure 
                      that uniquely identifies it (like a tuple).

        Returns:
        bool: True if the move is currently Tabu, False otherwise.
        """
        for tabu_move, tenure in self.tabu_list:
            if move == tabu_move and tenure > 0:
                return True  # The move is currently Tabu
        return False  # The move is not Tabu

    def update_tabu_list(self, move):
        """
        Update the Tabu list with a new move.

        Args:
        move (tuple): The move to add to the Tabu list. A move can be represented 
                      by any data structure that uniquely identifies it (like a tuple).
        """
        # Add the new move with its tenure
        self.tabu_list.append((move, self.tabu_tenure))

        # Decrement the tenure of existing moves and remove expired ones
        self.tabu_list = [(m, tenure - 1) for m, tenure in self.tabu_list if tenure > 1]

        # Ensure the Tabu list doesn't exceed its maximum size
        while len(self.tabu_list) > self.tabu_list_size:
            self.tabu_list.pop(0)  # Remove the oldest move


    def aspiration_criteria_met(self, candidate_schedule):
        """
        Determine if the candidate schedule meets the aspiration criteria,
        i.e., if it's significantly better than the current best schedule.

        Args:
        candidate_schedule (list): The schedule being considered.

        Returns:
        bool: True if the candidate schedule meets the aspiration criteria, False otherwise.
        """
        candidate_score = self.evaluate_schedule(candidate_schedule)
        return candidate_score > self.best_score + self.define_significant_improvement_threshold()
# Helper fonction for aspiration_criteria_met
    def define_significant_improvement_threshold(self):
        """
        Define a dynamic improvement threshold based on specific criteria.
        
        Returns:
        float: The dynamic threshold for significant improvement.
        """
        average_surgery_duration = self.calculate_average_surgery_duration()
        urgency_factor = self.calculate_urgency_factor()

        # Dynamic threshold based on surgery duration and urgency
        dynamic_threshold = average_surgery_duration * urgency_factor
        return dynamic_threshold

    def calculate_average_surgery_duration(self):
        """
        Calculate the average duration of surgeries.

        Returns:
        float: The average duration of surgeries.
        """
        # Assuming surgery_durations is a list of surgery duration times
        total_duration = sum(self.surgery_durations)
        number_of_surgeries = len(self.surgery_durations)
        return total_duration / number_of_surgeries if number_of_surgeries > 0 else 0

    def calculate_urgency_factor(self):
        """
        Calculate a factor based on the urgency of surgeries.

        Returns:
        float: A factor representing the average urgency.
        """
        # Assuming urgencies is a list of urgency values for surgeries
        total_urgency = sum(self.urgencies)
        number_of_surgeries = len(self.urgencies)
        average_urgency = total_urgency / number_of_surgeries if number_of_surgeries > 0 else 1
        return 1 + average_urgency / 10  # Example factor calculation
# End Helper of aspiration_criteria_met

    # Helper functions
    def identify_move(self, current_schedule, new_schedule):
        """
        Identify the specific change (move) made from the current schedule to the new schedule.
        This function should define how a move is represented.

        Args:
        current_schedule (list): The current schedule, represented as a list of surgeries.
        new_schedule (list): The new schedule, represented as a list of surgeries.

        Returns:
        tuple: A representation of the move, or None if no move is identified.
        """
        for i in range(len(current_schedule)):
            if current_schedule[i] != new_schedule[i]:
                # Assuming each surgery is represented as a dictionary and has a unique identifier
                return ('Swap', current_schedule[i]['id'], new_schedule[i]['id'])

        return None  # Return None if no change is found

    def calculate_resource_utilization_score(self, schedule):
        """
        Calculate the resource utilization score based on how effectively the operating rooms are used.

        Args:
        schedule (list): The schedule to evaluate, represented as a list of surgeries.
                         Each surgery should have 'start_time', 'end_time', and 'room' attributes.

        Returns:
        float: The resource utilization score.
        """
        total_operating_time, used_operating_time = 0, 0

        # Calculate total available operating time for each room
        for day, hours in self.operational_hours.items():
            total_operating_time += self.get_daily_operating_hours(hours)

        # Calculate used operating time
        for surgery in schedule:
            surgery_duration = self.calculate_surgery_duration(surgery['start_time'], surgery['end_time'])
            used_operating_time += surgery_duration

        # Avoid division by zero
        if total_operating_time == 0:
            return 0.0

        return (used_operating_time / total_operating_time) * 100
# Hlepers For calculate_resource_utilization_score
    def get_daily_operating_hours(self, hours):
        """
        Calculate the total operating hours in a day based on the operational hours.

        Args:
        hours (tuple): Start and end times of the operational hours (24-hour format).

        Returns:
        float: Total operational hours in the day.
        """
        start_time, end_time = map(self.convert_to_datetime, hours)
        return (end_time - start_time).total_seconds() / 3600  # Convert to hours

    def calculate_surgery_duration(self, start, end):
        """
        Calculate the duration of a surgery.

        Args:
        start (str): Start time of the surgery in 'YYYY-MM-DD HH:MM' format.
        end (str): End time of the surgery in 'YYYY-MM-DD HH:MM' format.

        Returns:
        float: Duration of the surgery in hours.
        """
        start_time = self.convert_to_datetime(start)
        end_time = self.convert_to_datetime(end)
        return (end_time - start_time).total_seconds() / 3600  # Convert to hours
# End of Helpers of calculate_resource_utilization_score
    def calculate_surgeon_workload_balance_score(self, schedule):
        """
        Assess the balance of workload among surgeons in the schedule.

        Args:
        schedule (list): The schedule to evaluate, represented as a list of surgeries.
                         Each surgery should have a 'surgeon_id' attribute.

        Returns:
        float: The surgeon workload balance score, higher is better.
        """
        surgeon_workloads = self.get_surgeon_workloads(schedule)
        if not surgeon_workloads:
            return 0  # Handle cases with no surgeries

        average_workload = sum(surgeon_workloads.values()) / len(surgeon_workloads)
        workload_variance = sum((workload - average_workload) ** 2 for workload in surgeon_workloads.values()) / len(surgeon_workloads)

        # A lower variance means a more balanced workload, so invert the variance for the score
        return 1 / (1 + workload_variance) if workload_variance != 0 else 1
# Helper Functions for calculate_surgeon_workload_balance_score
    def get_surgeon_workloads(self, schedule):
        """
        Calculate the workload for each surgeon based on the number of surgeries assigned.

        Args:
        schedule (list): The schedule to evaluate.

        Returns:
        dict: A dictionary with surgeon_id as keys and their workload (number of surgeries) as values.
        """
        workloads = {}
        for surgery in schedule:
            surgeon_id = surgery['surgeon_id']
            workloads[surgeon_id] = workloads.get(surgeon_id, 0) + 1        
# End Helpers of calculate_surgeon_workload_balance_score

    def calculate_patient_wait_time_score(self, schedule):
        """
        Evaluate the schedule based on patient wait times. Shorter wait times are better.

        Args:
        schedule (list): The schedule to evaluate, represented as a list of surgeries.
                         Each surgery should have 'patient_id', 'arrival_time', and 'start_time' attributes.

        Returns:
        float: The patient wait time score, higher is better.
        """
        total_wait_time = 0
        for surgery in schedule:
            patient_arrival = self.convert_to_datetime(surgery['arrival_time'])
            surgery_start = self.convert_to_datetime(surgery['start_time'])
            wait_duration = (surgery_start - patient_arrival).total_seconds() / 3600  # Convert to hours
            total_wait_time += wait_duration

        average_wait_time = total_wait_time / len(schedule) if schedule else 0

        # Invert the average wait time for scoring: shorter wait times should yield higher scores
        return 1 / (1 + average_wait_time) if average_wait_time != 0 else 1

    def calculate_average_surgery_duration(self, schedule):
        """
        Calculate the average duration of surgeries in the given schedule.

        Args:
        schedule (list): The schedule to evaluate, represented as a list of surgeries.
                         Each surgery should have 'start_time' and 'end_time' attributes.

        Returns:
        float: The average duration of surgeries in hours.
        """
        total_duration = 0
        for surgery in schedule:
            start_time = self.convert_to_datetime(surgery['start_time'])
            end_time = self.convert_to_datetime(surgery['end_time'])
            total_duration += (end_time - start_time).total_seconds()

        average_duration = total_duration / (len(schedule) * 3600) if schedule else 0
        return average_duration

    def calculate_urgency_factor(self, schedule):
        """
        Calculate an urgency factor for the given schedule based on the urgency of surgeries.

        Args:
        schedule (list): The schedule to evaluate, represented as a list of surgeries.
                         Each surgery is assumed to have an 'urgency' attribute.

        Returns:
        float: The calculated urgency factor.
        """
        total_urgency = sum(surgery['urgency'] for surgery in schedule)
        number_of_surgeries = len(schedule)

        # Avoid division by zero; return a default value if there are no surgeries
        if number_of_surgeries == 0:
            return 1.0

        average_urgency = total_urgency / number_of_surgeries

        # Scale the average urgency to obtain the factor, adjust the scaling as needed
        return 1 + average_urgency / 10

    def identify_move(self, current_schedule, new_schedule):
        """
        Identify the specific change (move) made from the current schedule to the new schedule.
        This function should define how a move is represented.

        Args:
        current_schedule (list): The current schedule, represented as a list of surgeries.
        new_schedule (list): The new schedule, represented as a list of surgeries.

        Returns:
        tuple: A representation of the move, or None if no move is identified.
        """
        for i in range(len(current_schedule)):
            if current_schedule[i] != new_schedule[i]:
                # Assuming each surgery is represented as a dictionary and has a unique identifier
                return self.define_move(current_schedule[i], new_schedule[i])

        return None  # Return None if no change is found

    def define_move(self, old_surgery, new_surgery):
        """
        Define the representation of a move based on the change in surgery details.

        Args:
        old_surgery (dict): The surgery details in the current schedule.
        new_surgery (dict): The surgery details in the new schedule.

        Returns:
        tuple: A representation of the move.
        """
        # Example: Define a move based on change in time or operating room
        if old_surgery['time'] != new_surgery['time']:
            return ('TimeChange', old_surgery['id'], old_surgery['time'], new_surgery['time'])
        elif old_surgery['room'] != new_surgery['room']:
            return ('RoomChange', old_surgery['id'], old_surgery['room'], new_surgery['room'])
        
        # Add more conditions as needed based on what constitutes a significant change in your context
        return ('GeneralChange', old_surgery['id'])

    # ... Additional helper methods and functions ...

# ... End of SurgeryScheduleTabuSearch class ...
surgeon_schedules = {
    1: [('2023-07-01 08:00', '2023-07-01 16:00'), ...],
    # ... other surgeons' schedules ...
}
operational_hours = {
     'Monday': ('08:00', '18:00'),
     # ... other days ...
}
operational_hours = {
    'Monday': ('08:00', '18:00'),
    # ... other days ...
}
tabu_search = SurgeryScheduleTabuSearch(surgeon_schedules)
tabu_search = SurgeryScheduleTabuSearch(operational_hours)
current_schedule = [...]  # Define a schedule
score = tabu_search.calculate_resource_utilization_score(current_schedule)
is_available = tabu_search.is_surgeon_available(1, '2023-07-01 09:00', 2)
time1 = ('2023-07-01 09:00', '2023-07-01 11:00')
time2 = ('2023-07-01 10:30', '2023-07-01 12:00')
overlapping = tabu_search.is_overlapping(time1, time2)
tabu_search = SurgeryScheduleTabuSearch()
time_to_check = datetime.now()
is_within_hours = tabu_search.is_within_operational_hours(time_to_check)
date_time_obj = tabu_search.convert_to_datetime('2023-07-01 09:00')
#tabu_search = SurgeryScheduleTabuSearch(tabu_list_size=10, tabu_tenure=5, ...)
move = ...  # Define a move
tabu_search.update_tabu_list(move)
#tabu_search = SurgeryScheduleTabuSearch(tabu_list_size=10, tabu_tenure=5, ...)
tabu_search = SurgeryScheduleTabuSearch(...)
tabu_search.surgery_durations = [...]  # List of surgery durations
tabu_search.urgencies = [...]          # List of surgery urgencies
improvement_threshold = tabu_search.define_significant_improvement_threshold()
current_schedule = [...]  # Define the current schedule
new_schedule = [...]      # Define the new schedule
move = tabu_search.identify_move(current_schedule, new_schedule)
tabu_search = SurgeryScheduleTabuSearch(operational_hours)
current_schedule = [...]  # Define a schedule
score = tabu_search.calculate_resource_utilization_score(current_schedule)
